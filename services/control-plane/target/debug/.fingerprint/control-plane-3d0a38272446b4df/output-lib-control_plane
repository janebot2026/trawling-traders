{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `AgentConfig` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":1405,"byte_end":1416,"line_start":45,"line_end":45,"column_start":23,"column_end":34,"is_primary":true,"text":[{"text":"        agent_config: AgentConfig {","highlight_start":23,"highlight_end":34}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `AgentConfig` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:45:23\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         agent_config: AgentConfig {\n   \u001b[1m\u001b[94m|\u001b[0m                       \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `TradingParams` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":1811,"byte_end":1824,"line_start":54,"line_end":54,"column_start":25,"column_end":38,"is_primary":true,"text":[{"text":"        trading_params: TradingParams {","highlight_start":25,"highlight_end":38}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `TradingParams` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:54:25\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         trading_params: TradingParams {\n   \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `LlmConfig` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2133,"byte_end":2142,"line_start":61,"line_end":61,"column_start":21,"column_end":30,"is_primary":true,"text":[{"text":"        llm_config: LlmConfig {","highlight_start":21,"highlight_end":30}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `LlmConfig` in this scope\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:61:21\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         llm_config: LlmConfig {\n   \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `WalletReportRequest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":3915,"byte_end":3934,"line_start":115,"line_end":115,"column_start":21,"column_end":40,"is_primary":true,"text":[{"text":"    Json(req): Json<WalletReportRequest>,","highlight_start":21,"highlight_end":40}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":3823,"byte_end":3823,"line_start":112,"line_end":112,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"pub async fn report_wallet(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<WalletReportRequest>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `WalletReportRequest` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:115:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m115\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(req): Json<WalletReportRequest>,\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub async fn report_wallet\u001b[92m<WalletReportRequest>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m+++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `HeartbeatRequest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/models/mod.rs","byte_start":7489,"byte_end":7519,"line_start":312,"line_end":312,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub struct BotHeartbeatRequest {","highlight_start":1,"highlight_end":31}],"label":"similarly named struct `BotHeartbeatRequest` defined here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":5144,"byte_end":5160,"line_start":150,"line_end":150,"column_start":21,"column_end":37,"is_primary":true,"text":[{"text":"    Json(req): Json<HeartbeatRequest>,","highlight_start":21,"highlight_end":37}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"a struct with a similar name exists","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5144,"byte_end":5160,"line_start":150,"line_end":150,"column_start":21,"column_end":37,"is_primary":true,"text":[{"text":"    Json(req): Json<HeartbeatRequest>,","highlight_start":21,"highlight_end":37}],"label":null,"suggested_replacement":"BotHeartbeatRequest","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5052,"byte_end":5052,"line_start":147,"line_end":147,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"pub async fn heartbeat(","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":"<HeartbeatRequest>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `HeartbeatRequest` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:150:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m150\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(req): Json<HeartbeatRequest>,\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:312:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m312\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct BotHeartbeatRequest {\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------------------------\u001b[0m \u001b[1m\u001b[94msimilarly named struct `BotHeartbeatRequest` defined here\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: a struct with a similar name exists\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m150\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    Json(req): Json<\u001b[92mBot\u001b[0mHeartbeatRequest>,\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[92m+++\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m147\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub async fn heartbeat\u001b[92m<HeartbeatRequest>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                       \u001b[92m++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `EventsBatchRequest` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6895,"byte_end":6913,"line_start":199,"line_end":199,"column_start":21,"column_end":39,"is_primary":true,"text":[{"text":"    Json(req): Json<EventsBatchRequest>,","highlight_start":21,"highlight_end":39}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6803,"byte_end":6803,"line_start":196,"line_end":196,"column_start":27,"column_end":27,"is_primary":true,"text":[{"text":"pub async fn ingest_events(","highlight_start":27,"highlight_end":27}],"label":null,"suggested_replacement":"<EventsBatchRequest>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `EventsBatchRequest` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:199:21\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m199\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     Json(req): Json<EventsBatchRequest>,\n    \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub async fn ingest_events\u001b[92m<EventsBatchRequest>\u001b[0m(\n    \u001b[1m\u001b[94m|\u001b[0m                           \u001b[92m++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find type `CronJob` in this scope","code":{"code":"E0412","explanation":"A used type name is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":8713,"byte_end":8720,"line_start":251,"line_end":251,"column_start":54,"column_end":61,"is_primary":true,"text":[{"text":"fn generate_cron_jobs(config: &ConfigVersion) -> Vec<CronJob> {","highlight_start":54,"highlight_end":61}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you might be missing a type parameter","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":8681,"byte_end":8681,"line_start":251,"line_end":251,"column_start":22,"column_end":22,"is_primary":true,"text":[{"text":"fn generate_cron_jobs(config: &ConfigVersion) -> Vec<CronJob> {","highlight_start":22,"highlight_end":22}],"label":null,"suggested_replacement":"<CronJob>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0412]\u001b[0m\u001b[1m: cannot find type `CronJob` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:251:54\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m251\u001b[0m \u001b[1m\u001b[94m|\u001b[0m fn generate_cron_jobs(config: &ConfigVersion) -> Vec<CronJob> {\n    \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you might be missing a type parameter\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m251\u001b[0m \u001b[1m\u001b[94m| \u001b[0mfn generate_cron_jobs\u001b[92m<CronJob>\u001b[0m(config: &ConfigVersion) -> Vec<CronJob> {\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[92m+++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `CronJob` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":8770,"byte_end":8777,"line_start":254,"line_end":254,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"    jobs.push(CronJob {","highlight_start":15,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `CronJob` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:254:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m254\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     jobs.push(CronJob {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `CronJob` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":9166,"byte_end":9173,"line_start":266,"line_end":266,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"    jobs.push(CronJob {","highlight_start":15,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `CronJob` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:266:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m266\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     jobs.push(CronJob {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `CronJob` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":9608,"byte_end":9615,"line_start":278,"line_end":278,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"    jobs.push(CronJob {","highlight_start":15,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `CronJob` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:278:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m278\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     jobs.push(CronJob {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `CronJob` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":9787,"byte_end":9794,"line_start":284,"line_end":284,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"    jobs.push(CronJob {","highlight_start":15,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `CronJob` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:284:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m284\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     jobs.push(CronJob {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find struct, variant or union type `CronJob` in this scope","code":{"code":"E0422","explanation":"An identifier that is neither defined nor a struct was used.\n\nErroneous code example:\n\n```compile_fail,E0422\nfn main () {\n    let x = Foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `Foo` is undefined, so it inherently isn't anything, and\ndefinitely not a struct.\n\n```compile_fail\nfn main () {\n    let foo = 1;\n    let x = foo { x: 1, y: 2 };\n}\n```\n\nIn this case, `foo` is defined, but is not a struct, so Rust can't use it as\none.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":9960,"byte_end":9967,"line_start":290,"line_end":290,"column_start":15,"column_end":22,"is_primary":true,"text":[{"text":"    jobs.push(CronJob {","highlight_start":15,"highlight_end":22}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0422]\u001b[0m\u001b[1m: cannot find struct, variant or union type `CronJob` in this scope\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:290:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m290\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     jobs.push(CronJob {\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in this scope\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `rust_decimal::prelude::*`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/algorithms/breakout.rs","byte_start":332,"byte_end":356,"line_start":10,"line_end":10,"column_start":5,"column_end":29,"is_primary":true,"text":[{"text":"use rust_decimal::prelude::*;","highlight_start":5,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/algorithms/breakout.rs","byte_start":328,"byte_end":358,"line_start":10,"line_end":11,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use rust_decimal::prelude::*;","highlight_start":1,"highlight_end":30},{"text":"use std::str::FromStr;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `rust_decimal::prelude::*`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/algorithms/breakout.rs:10:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m10\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use rust_decimal::prelude::*;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused import: `AlgoConfig`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/brain/engine.rs","byte_start":97,"byte_end":107,"line_start":4,"line_end":4,"column_start":14,"column_end":24,"is_primary":true,"text":[{"text":"    config::{AlgoConfig, AlgoMode, TraderBrainConfig},","highlight_start":14,"highlight_end":24}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/brain/engine.rs","byte_start":97,"byte_end":109,"line_start":4,"line_end":4,"column_start":14,"column_end":26,"is_primary":true,"text":[{"text":"    config::{AlgoConfig, AlgoMode, TraderBrainConfig},","highlight_start":14,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `AlgoConfig`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/brain/engine.rs:4:14\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m4\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     config::{AlgoConfig, AlgoMode, TraderBrainConfig},\n  \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `crate::brain::signal::Signal`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/brain/factors.rs","byte_start":190,"byte_end":218,"line_start":6,"line_end":6,"column_start":5,"column_end":33,"is_primary":true,"text":[{"text":"use crate::brain::signal::Signal;","highlight_start":5,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/brain/factors.rs","byte_start":186,"byte_end":220,"line_start":6,"line_end":7,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use crate::brain::signal::Signal;","highlight_start":1,"highlight_end":34},{"text":"","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `crate::brain::signal::Signal`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/brain/factors.rs:6:5\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m6\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use crate::brain::signal::Signal;\n  \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `warn`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/bots.rs","byte_start":126,"byte_end":130,"line_start":7,"line_end":7,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":124,"byte_end":130,"line_start":7,"line_end":7,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":19,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":119,"byte_end":120,"line_start":7,"line_end":7,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":130,"byte_end":131,"line_start":7,"line_end":7,"column_start":25,"column_end":26,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":25,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `warn`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:7:21\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use tracing::{info, warn};\n  \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[33m^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":717,"byte_end":720,"line_start":27,"line_end":27,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"    let bots = sqlx::query_as::<_, Bot>(","highlight_start":36,"highlight_end":39}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:27:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bots = sqlx::query_as::<_, Bot>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":717,"byte_end":720,"line_start":27,"line_end":27,"column_start":36,"column_end":39,"is_primary":true,"text":[{"text":"    let bots = sqlx::query_as::<_, Bot>(","highlight_start":36,"highlight_end":39}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:27:36\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bots = sqlx::query_as::<_, Bot>(\n    \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_all` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":697,"byte_end":826,"line_start":27,"line_end":31,"column_start":16,"column_end":6,"is_primary":false,"text":[{"text":"    let bots = sqlx::query_as::<_, Bot>(","highlight_start":16,"highlight_end":41},{"text":"        \"SELECT * FROM bots WHERE user_id = $1 ORDER BY created_at DESC\"","highlight_start":1,"highlight_end":73},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_all(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":826,"byte_end":835,"line_start":31,"line_end":31,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_all(&state.db)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_all` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:31:6\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bots = sqlx::query_as::<_, Bot>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ________________-\u001b[0m\n \u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \"SELECT * FROM bots WHERE user_id = $1 ORDER BY created_at DESC\"\n \u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     )\n \u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(user_id)\n \u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_all(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":697,"byte_end":857,"line_start":27,"line_end":32,"column_start":16,"column_end":11,"is_primary":true,"text":[{"text":"    let bots = sqlx::query_as::<_, Bot>(","highlight_start":16,"highlight_end":41},{"text":"        \"SELECT * FROM bots WHERE user_id = $1 ORDER BY created_at DESC\"","highlight_start":1,"highlight_end":73},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .fetch_all(&state.db)","highlight_start":1,"highlight_end":26},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:27:16\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bots = sqlx::query_as::<_, Bot>(\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ________________^\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         \"SELECT * FROM bots WHERE user_id = $1 ORDER BY created_at DESC\"\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     )\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .bind(user_id)\n\u001b[1m\u001b[94m31\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.db)\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":911,"byte_end":912,"line_start":33,"line_end":33,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":872,"byte_end":873,"line_start":33,"line_end":33,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":873,"byte_end":873,"line_start":33,"line_end":33,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:33:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":3447,"byte_end":3450,"line_start":109,"line_end":109,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(","highlight_start":35,"highlight_end":38}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:109:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":3447,"byte_end":3450,"line_start":109,"line_end":109,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(","highlight_start":35,"highlight_end":38}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:109:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":3427,"byte_end":3799,"line_start":109,"line_end":122,"column_start":15,"column_end":6,"is_primary":false,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(","highlight_start":15,"highlight_end":40},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        INSERT INTO bots (","highlight_start":1,"highlight_end":27},{"text":"            id, user_id, name, status, persona, region, desired_version_id, config_status","highlight_start":1,"highlight_end":90},{"text":"        ) VALUES ($1, $2, $3, 'provisioning', $4, 'nyc1', $5, 'pending')","highlight_start":1,"highlight_end":73},{"text":"        RETURNING *","highlight_start":1,"highlight_end":20},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(bot_id)","highlight_start":1,"highlight_end":18},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .bind(&req.name)","highlight_start":1,"highlight_end":21},{"text":"    .bind(req.persona)","highlight_start":1,"highlight_end":23},{"text":"    .bind(config_id)","highlight_start":1,"highlight_end":21},{"text":"    .fetch_one(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":3799,"byte_end":3808,"line_start":122,"line_end":122,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_one(&state.db)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:122:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________-\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         INSERT INTO bots (\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             id, user_id, name, status, persona, region, desired_version_id, config_status\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m121\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(config_id)\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":3427,"byte_end":3830,"line_start":109,"line_end":123,"column_start":15,"column_end":11,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(","highlight_start":15,"highlight_end":40},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        INSERT INTO bots (","highlight_start":1,"highlight_end":27},{"text":"            id, user_id, name, status, persona, region, desired_version_id, config_status","highlight_start":1,"highlight_end":90},{"text":"        ) VALUES ($1, $2, $3, 'provisioning', $4, 'nyc1', $5, 'pending')","highlight_start":1,"highlight_end":73},{"text":"        RETURNING *","highlight_start":1,"highlight_end":20},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(bot_id)","highlight_start":1,"highlight_end":18},{"text":"    .bind(user_id)","highlight_start":1,"highlight_end":19},{"text":"    .bind(&req.name)","highlight_start":1,"highlight_end":21},{"text":"    .bind(req.persona)","highlight_start":1,"highlight_end":23},{"text":"    .bind(config_id)","highlight_start":1,"highlight_end":21},{"text":"    .fetch_one(&state.db)","highlight_start":1,"highlight_end":26},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:109:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m109\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________^\u001b[0m\n\u001b[1m\u001b[94m110\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m111\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         INSERT INTO bots (\n\u001b[1m\u001b[94m112\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             id, user_id, name, status, persona, region, desired_version_id, config_status\n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m122\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_one(&state.db)\n\u001b[1m\u001b[94m123\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":3884,"byte_end":3885,"line_start":124,"line_end":124,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":3845,"byte_end":3846,"line_start":124,"line_end":124,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":3846,"byte_end":3846,"line_start":124,"line_end":124,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:124:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":6293,"byte_end":6296,"line_start":195,"line_end":195,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:195:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":6293,"byte_end":6296,"line_start":195,"line_end":195,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:195:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":6273,"byte_end":6365,"line_start":195,"line_end":197,"column_start":15,"column_end":10,"is_primary":false,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":6365,"byte_end":6374,"line_start":197,"line_end":197,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:197:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________-\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m197\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":6273,"byte_end":6400,"line_start":195,"line_end":198,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:195:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________^\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m197\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m198\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":7759,"byte_end":7762,"line_start":235,"line_end":235,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:235:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":7759,"byte_end":7762,"line_start":235,"line_end":235,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:235:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":7739,"byte_end":7831,"line_start":235,"line_end":237,"column_start":20,"column_end":10,"is_primary":false,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":7831,"byte_end":7840,"line_start":237,"line_end":237,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:237:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ____________________-\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m237\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":7739,"byte_end":7866,"line_start":235,"line_end":238,"column_start":20,"column_end":15,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:235:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m235\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m236\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m237\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m238\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":11013,"byte_end":11016,"line_start":325,"line_end":325,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:325:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":11013,"byte_end":11016,"line_start":325,"line_end":325,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:325:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":10993,"byte_end":11085,"line_start":325,"line_end":327,"column_start":20,"column_end":10,"is_primary":false,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":11085,"byte_end":11094,"line_start":327,"line_end":327,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:327:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ____________________-\u001b[0m\n\u001b[1m\u001b[94m326\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m327\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":10993,"byte_end":11120,"line_start":325,"line_end":328,"column_start":20,"column_end":15,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:325:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m325\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m326\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m327\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m328\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":12739,"byte_end":12742,"line_start":370,"line_end":370,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:370:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":12739,"byte_end":12742,"line_start":370,"line_end":370,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:370:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":12719,"byte_end":12811,"line_start":370,"line_end":372,"column_start":20,"column_end":10,"is_primary":false,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":12811,"byte_end":12820,"line_start":372,"line_end":372,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:372:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ____________________-\u001b[0m\n\u001b[1m\u001b[94m371\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m372\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":12719,"byte_end":12846,"line_start":370,"line_end":373,"column_start":20,"column_end":15,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:370:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m370\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m371\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m372\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m373\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":14282,"byte_end":14285,"line_start":417,"line_end":417,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:417:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m417\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":14282,"byte_end":14285,"line_start":417,"line_end":417,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":40,"highlight_end":43}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:417:40\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m417\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                        \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":14262,"byte_end":14354,"line_start":417,"line_end":419,"column_start":20,"column_end":10,"is_primary":false,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":14354,"byte_end":14363,"line_start":419,"line_end":419,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:419:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m417\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ____________________-\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m419\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":14262,"byte_end":14389,"line_start":417,"line_end":420,"column_start":20,"column_end":15,"is_primary":true,"text":[{"text":"    let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":20,"highlight_end":80},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:417:20\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m417\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot: Bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ____________________^\u001b[0m\n\u001b[1m\u001b[94m418\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m419\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m420\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":434,"byte_end":437,"line_start":20,"line_end":20,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:20:35\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":434,"byte_end":437,"line_start":20,"line_end":20,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:20:35\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":414,"byte_end":506,"line_start":20,"line_end":22,"column_start":15,"column_end":10,"is_primary":false,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":506,"byte_end":515,"line_start":22,"line_end":22,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:22:10\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________-\u001b[0m\n \u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n \u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":414,"byte_end":541,"line_start":20,"line_end":23,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:20:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________^\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m22\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"/usr/src/debug/rust/rustc-1.92.0-src/library/alloc/src/macros.rs","byte_start":3901,"byte_end":3962,"line_start":108,"line_end":108,"column_start":13,"column_end":74,"is_primary":true,"text":[],"label":"expected `i32`, found `String`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/handlers/sync.rs","byte_start":1324,"byte_end":1354,"line_start":43,"line_end":43,"column_start":18,"column_end":48,"is_primary":false,"text":[{"text":"        version: format!(\"v{}\", config.version),","highlight_start":18,"highlight_end":48}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"format!","def_site_span":{"file_name":"/usr/src/debug/rust/rustc-1.92.0-src/library/alloc/src/macros.rs","byte_start":3807,"byte_end":3826,"line_start":105,"line_end":105,"column_start":1,"column_end":20,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:43:18\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         version: format!(\"v{}\", config.version),\n   \u001b[1m\u001b[94m|\u001b[0m                  \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `i32`, found `String`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"struct `models::BotConfigResponse` has no field named `hash`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":1364,"byte_end":1368,"line_start":44,"line_end":44,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"        hash: config_hash,","highlight_start":9,"highlight_end":13}],"label":"`models::BotConfigResponse` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `version_id`, `config`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `models::BotConfigResponse` has no field named `hash`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:44:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m44\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         hash: config_hash,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91m`models::BotConfigResponse` does not have this field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `version_id`, `config`\n\n"}
{"$message_type":"diagnostic","message":"struct `models::BotConfigResponse` has no field named `agent_config`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":1391,"byte_end":1403,"line_start":45,"line_end":45,"column_start":9,"column_end":21,"is_primary":true,"text":[{"text":"        agent_config: AgentConfig {","highlight_start":9,"highlight_end":21}],"label":"`models::BotConfigResponse` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `version_id`, `config`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `models::BotConfigResponse` has no field named `agent_config`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:45:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m45\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         agent_config: AgentConfig {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`models::BotConfigResponse` does not have this field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `version_id`, `config`\n\n"}
{"$message_type":"diagnostic","message":"struct `models::BotConfigResponse` has no field named `cron_jobs`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":1776,"byte_end":1785,"line_start":53,"line_end":53,"column_start":9,"column_end":18,"is_primary":true,"text":[{"text":"        cron_jobs,","highlight_start":9,"highlight_end":18}],"label":"`models::BotConfigResponse` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `version_id`, `config`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `models::BotConfigResponse` has no field named `cron_jobs`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:53:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         cron_jobs,\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`models::BotConfigResponse` does not have this field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `version_id`, `config`\n\n"}
{"$message_type":"diagnostic","message":"struct `models::BotConfigResponse` has no field named `trading_params`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":1795,"byte_end":1809,"line_start":54,"line_end":54,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"        trading_params: TradingParams {","highlight_start":9,"highlight_end":23}],"label":"`models::BotConfigResponse` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `version_id`, `config`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `models::BotConfigResponse` has no field named `trading_params`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:54:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m54\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         trading_params: TradingParams {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`models::BotConfigResponse` does not have this field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `version_id`, `config`\n\n"}
{"$message_type":"diagnostic","message":"struct `models::BotConfigResponse` has no field named `llm_config`","code":{"code":"E0560","explanation":"An unknown field was specified into a structure.\n\nErroneous code example:\n\n```compile_fail,E0560\nstruct Simba {\n    mother: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 };\n// error: structure `Simba` has no field named `father`\n```\n\nVerify you didn't misspell the field's name or that the field exists. Example:\n\n```\nstruct Simba {\n    mother: u32,\n    father: u32,\n}\n\nlet s = Simba { mother: 1, father: 0 }; // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2121,"byte_end":2131,"line_start":61,"line_end":61,"column_start":9,"column_end":19,"is_primary":true,"text":[{"text":"        llm_config: LlmConfig {","highlight_start":9,"highlight_end":19}],"label":"`models::BotConfigResponse` does not have this field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available fields are: `version_id`, `config`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0560]\u001b[0m\u001b[1m: struct `models::BotConfigResponse` has no field named `llm_config`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:61:9\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m61\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         llm_config: LlmConfig {\n   \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91m`models::BotConfigResponse` does not have this field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available fields are: `version_id`, `config`\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2555,"byte_end":2558,"line_start":76,"line_end":76,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:76:35\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2555,"byte_end":2558,"line_start":76,"line_end":76,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:76:35\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2535,"byte_end":2627,"line_start":76,"line_end":78,"column_start":15,"column_end":10,"is_primary":false,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":2627,"byte_end":2636,"line_start":78,"line_end":78,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:78:10\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________-\u001b[0m\n \u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n \u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2535,"byte_end":2662,"line_start":76,"line_end":79,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:76:15\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m76\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________^\u001b[0m\n\u001b[1m\u001b[94m77\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m78\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m79\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2720,"byte_end":2721,"line_start":80,"line_end":80,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":2681,"byte_end":2682,"line_start":80,"line_end":80,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":2682,"byte_end":2682,"line_start":80,"line_end":80,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:80:19\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m80\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n   \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"no field `hash` on type `models::ConfigAckRequest`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":3088,"byte_end":3092,"line_start":92,"line_end":92,"column_start":12,"column_end":16,"is_primary":true,"text":[{"text":"    if ack.hash != expected_hash {","highlight_start":12,"highlight_end":16}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available field is: `version_id`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `hash` on type `models::ConfigAckRequest`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:92:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m92\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     if ack.hash != expected_hash {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available field is: `version_id`\n\n"}
{"$message_type":"diagnostic","message":"no field `hash` on type `models::ConfigAckRequest`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":3209,"byte_end":3213,"line_start":93,"line_end":93,"column_start":98,"column_end":102,"is_primary":true,"text":[{"text":"        warn!(\"Config hash mismatch for bot {}: expected {}, got {}\", bot_id, expected_hash, ack.hash);","highlight_start":98,"highlight_end":102}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available field is: `version_id`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `hash` on type `models::ConfigAckRequest`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:93:98\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m93\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         warn!(\"Config hash mismatch for bot {}: expected {}, got {}\", bot_id, expected_hash, ack.hash);\n   \u001b[1m\u001b[94m|\u001b[0m                                                                                                  \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available field is: `version_id`\n\n"}
{"$message_type":"diagnostic","message":"no field `version` on type `models::ConfigAckRequest`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":3675,"byte_end":3682,"line_start":106,"line_end":106,"column_start":72,"column_end":79,"is_primary":true,"text":[{"text":"    info!(\"Bot {} acknowledged config version {} at {:?}\", bot_id, ack.version, ack.applied_at);","highlight_start":72,"highlight_end":79}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available field is: `version_id`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `version` on type `models::ConfigAckRequest`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:106:72\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     info!(\"Bot {} acknowledged config version {} at {:?}\", bot_id, ack.version, ack.applied_at);\n    \u001b[1m\u001b[94m|\u001b[0m                                                                        \u001b[1m\u001b[91m^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available field is: `version_id`\n\n"}
{"$message_type":"diagnostic","message":"no field `applied_at` on type `models::ConfigAckRequest`","code":{"code":"E0609","explanation":"Attempted to access a nonexistent field in a struct.\n\nErroneous code example:\n\n```compile_fail,E0609\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.foo); // error: no field `foo` on type `StructWithFields`\n```\n\nTo fix this error, check that you didn't misspell the field's name or that the\nfield actually exists. Example:\n\n```\nstruct StructWithFields {\n    x: u32,\n}\n\nlet s = StructWithFields { x: 0 };\nprintln!(\"{}\", s.x); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":3688,"byte_end":3698,"line_start":106,"line_end":106,"column_start":85,"column_end":95,"is_primary":true,"text":[{"text":"    info!(\"Bot {} acknowledged config version {} at {:?}\", bot_id, ack.version, ack.applied_at);","highlight_start":85,"highlight_end":95}],"label":"unknown field","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"available field is: `version_id`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0609]\u001b[0m\u001b[1m: no field `applied_at` on type `models::ConfigAckRequest`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:106:85\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m106\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     info!(\"Bot {} acknowledged config version {} at {:?}\", bot_id, ack.version, ack.applied_at);\n    \u001b[1m\u001b[94m|\u001b[0m                                                                                     \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91munknown field\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: available field is: `version_id`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":4129,"byte_end":4130,"line_start":118,"line_end":118,"column_start":78,"column_end":79,"is_primary":false,"text":[{"text":"    if req.wallet_address.len() != 44 || !req.wallet_address.chars().all(|c| c.is_alphanumeric()) {","highlight_start":78,"highlight_end":79}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":4126,"byte_end":4127,"line_start":118,"line_end":118,"column_start":75,"column_end":76,"is_primary":true,"text":[{"text":"    if req.wallet_address.len() != 44 || !req.wallet_address.chars().all(|c| c.is_alphanumeric()) {","highlight_start":75,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":4127,"byte_end":4127,"line_start":118,"line_end":118,"column_start":76,"column_end":76,"is_primary":true,"text":[{"text":"    if req.wallet_address.len() != 44 || !req.wallet_address.chars().all(|c| c.is_alphanumeric()) {","highlight_start":76,"highlight_end":76}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:118:75\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     if req.wallet_address.len() != 44 || !req.wallet_address.chars().all(|c| c.is_alphanumeric()) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                           \u001b[1m\u001b[91m^\u001b[0m  \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m118\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    if req.wallet_address.len() != 44 || !req.wallet_address.chars().all(|c\u001b[92m: /* Type */\u001b[0m| c.is_alphanumeric()) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                                            \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6261,"byte_end":6264,"line_start":181,"line_end":181,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:181:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6261,"byte_end":6264,"line_start":181,"line_end":181,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:181:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6241,"byte_end":6333,"line_start":181,"line_end":183,"column_start":15,"column_end":10,"is_primary":false,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":6333,"byte_end":6342,"line_start":183,"line_end":183,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:183:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________-\u001b[0m\n\u001b[1m\u001b[94m182\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6241,"byte_end":6368,"line_start":181,"line_end":184,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:181:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m181\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________^\u001b[0m\n\u001b[1m\u001b[94m182\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m183\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m184\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6426,"byte_end":6427,"line_start":185,"line_end":185,"column_start":58,"column_end":59,"is_primary":false,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":58,"highlight_end":59}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":6387,"byte_end":6388,"line_start":185,"line_end":185,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":6388,"byte_end":6388,"line_start":185,"line_end":185,"column_start":20,"column_end":20,"is_primary":true,"text":[{"text":"        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":20,"highlight_end":20}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:185:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m185\u001b[0m \u001b[1m\u001b[94m| \u001b[0m        .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                    \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":7688,"byte_end":7691,"line_start":223,"line_end":223,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:223:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m223\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `sqlx::Decode<'_, _>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `IpAddr: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":7688,"byte_end":7691,"line_start":223,"line_end":223,"column_start":35,"column_end":38,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":35,"highlight_end":38}],"label":"the trait `Type<_>` is not implemented for `IpAddr`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 78 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `std::option::Option<IpAddr>` to implement `Type<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"required for `models::Bot` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":2985,"byte_end":2992,"line_start":124,"line_end":124,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3017,"byte_end":3020,"line_start":125,"line_end":125,"column_start":12,"column_end":15,"is_primary":true,"text":[{"text":"pub struct Bot {","highlight_start":12,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `IpAddr: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:223:35\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m223\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m                                   \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `IpAddr`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 78 others\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: required for `std::option::Option<IpAddr>` to implement `Type<_>`\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Bot` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:124:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m124\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":7668,"byte_end":7760,"line_start":223,"line_end":225,"column_start":15,"column_end":10,"is_primary":false,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":10}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":7760,"byte_end":7769,"line_start":225,"line_end":225,"column_start":10,"column_end":19,"is_primary":true,"text":[{"text":"        .fetch_one(&state.db)","highlight_start":10,"highlight_end":19}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3006,"byte_end":3020,"line_start":125,"line_end":125,"column_start":1,"column_end":15,"is_primary":false,"text":[{"text":"pub struct Bot {","highlight_start":1,"highlight_end":15}],"label":"doesn't satisfy `models::Bot: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`IpAddr: sqlx::Decode<'_, Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`\n`IpAddr: Type<Postgres>`\nwhich is required by `models::Bot: FromRow<'r, PgRow>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_one` exists for struct `QueryAs<'_, Postgres, models::Bot, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:225:10\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m223\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m _______________-\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m225\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         .fetch_one(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Bot, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_________|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:125:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m125\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Bot {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m--------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Bot: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `IpAddr: sqlx::Decode<'_, Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n            `IpAddr: Type<Postgres>`\n            which is required by `models::Bot: FromRow<'r, PgRow>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":7668,"byte_end":7795,"line_start":223,"line_end":226,"column_start":15,"column_end":15,"is_primary":true,"text":[{"text":"    let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")","highlight_start":15,"highlight_end":75},{"text":"        .bind(bot_id)","highlight_start":1,"highlight_end":22},{"text":"        .fetch_one(&state.db)","highlight_start":1,"highlight_end":30},{"text":"        .await","highlight_start":1,"highlight_end":15}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:223:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m223\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let bot = sqlx::query_as::<_, Bot>(\"SELECT * FROM bots WHERE id = $1\")\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m _______________^\u001b[0m\n\u001b[1m\u001b[94m224\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .bind(bot_id)\n\u001b[1m\u001b[94m225\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .fetch_one(&state.db)\n\u001b[1m\u001b[94m226\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|______________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused import: `rust_decimal::prelude`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/algorithms/trend.rs","byte_start":322,"byte_end":343,"line_start":11,"line_end":11,"column_start":5,"column_end":26,"is_primary":true,"text":[{"text":"use rust_decimal::prelude::*;","highlight_start":5,"highlight_end":26}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `rust_decimal::prelude`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/algorithms/trend.rs:11:5\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m11\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use rust_decimal::prelude::*;\n   \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"value assigned to `confidence` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"src/brain/engine.rs","byte_start":7621,"byte_end":7624,"line_start":250,"line_end":250,"column_start":30,"column_end":33,"is_primary":true,"text":[{"text":"        let mut confidence = 0.0;","highlight_start":30,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"`#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: value assigned to `confidence` is never read\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/brain/engine.rs:250:30\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m250\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         let mut confidence = 0.0;\n    \u001b[1m\u001b[94m|\u001b[0m                              \u001b[1m\u001b[33m^^^\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: maybe it is overwritten before being read?\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_assignments)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `bot_name`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/bots.rs","byte_start":4582,"byte_end":4590,"line_start":145,"line_end":145,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"async fn spawn_bot_droplet(bot_id: Uuid, bot_name: String, config_id: Uuid) {","highlight_start":42,"highlight_end":50}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":4582,"byte_end":4590,"line_start":145,"line_end":145,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"async fn spawn_bot_droplet(bot_id: Uuid, bot_name: String, config_id: Uuid) {","highlight_start":42,"highlight_end":50}],"label":null,"suggested_replacement":"_bot_name","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `bot_name`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:145:42\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m145\u001b[0m \u001b[1m\u001b[94m|\u001b[0m async fn spawn_bot_droplet(bot_id: Uuid, bot_name: String, config_id: Uuid) {\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[33m^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_bot_name`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `config_id`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/bots.rs","byte_start":4600,"byte_end":4609,"line_start":145,"line_end":145,"column_start":60,"column_end":69,"is_primary":true,"text":[{"text":"async fn spawn_bot_droplet(bot_id: Uuid, bot_name: String, config_id: Uuid) {","highlight_start":60,"highlight_end":69}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":4600,"byte_end":4609,"line_start":145,"line_end":145,"column_start":60,"column_end":69,"is_primary":true,"text":[{"text":"async fn spawn_bot_droplet(bot_id: Uuid, bot_name: String, config_id: Uuid) {","highlight_start":60,"highlight_end":69}],"label":null,"suggested_replacement":"_config_id","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `config_id`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:145:60\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m145\u001b[0m \u001b[1m\u001b[94m|\u001b[0m async fn spawn_bot_droplet(bot_id: Uuid, bot_name: String, config_id: Uuid) {\n    \u001b[1m\u001b[94m|\u001b[0m                                                            \u001b[1m\u001b[33m^^^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_config_id`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 71 previous errors; 8 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 71 previous errors; 8 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282, E0308, E0412, E0422, E0560, E0599, E0609.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0282, E0308, E0412, E0422, E0560, E0599, E0609.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
