{"$message_type":"diagnostic","message":"unused import: `warn`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/bots.rs","byte_start":115,"byte_end":119,"line_start":7,"line_end":7,"column_start":21,"column_end":25,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":21,"highlight_end":25}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":113,"byte_end":119,"line_start":7,"line_end":7,"column_start":19,"column_end":25,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":19,"highlight_end":25}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":108,"byte_end":109,"line_start":7,"line_end":7,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":119,"byte_end":120,"line_start":7,"line_end":7,"column_start":25,"column_end":26,"is_primary":true,"text":[{"text":"use tracing::{info, warn};","highlight_start":25,"highlight_end":26}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused import: `warn`\u001b[0m\n \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:7:21\n  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m7\u001b[0m \u001b[1m\u001b[94m|\u001b[0m use tracing::{info, warn};\n  \u001b[1m\u001b[94m|\u001b[0m                     \u001b[1m\u001b[33m^^^^\u001b[0m\n  \u001b[1m\u001b[94m|\u001b[0m\n  \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"use of moved value: `req.persona`","code":{"code":"E0382","explanation":"A variable was used after its contents have been moved elsewhere.\n\nErroneous code example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`. Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the\n[Understanding Ownership][understanding-ownership] chapter in the Book.\n\n[understanding-ownership]: https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":2618,"byte_end":2629,"line_start":86,"line_end":86,"column_start":11,"column_end":22,"is_primary":false,"text":[{"text":"    .bind(req.persona)","highlight_start":11,"highlight_end":22}],"label":"value moved here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":3565,"byte_end":3576,"line_start":116,"line_end":116,"column_start":11,"column_end":22,"is_primary":true,"text":[{"text":"    .bind(req.persona)","highlight_start":11,"highlight_end":22}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"move occurs because `req.persona` has type `Persona`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0382]\u001b[0m\u001b[1m: use of moved value: `req.persona`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:116:11\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(req.persona)\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m-----------\u001b[0m \u001b[1m\u001b[94mvalue moved here\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(req.persona)\n    \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[91m^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mvalue used here after move\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: move occurs because `req.persona` has type `Persona`, which does not implement the `Copy` trait\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":8877,"byte_end":8883,"line_start":267,"line_end":267,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"    let metrics = sqlx::query_as::<_, Metric>(","highlight_start":39,"highlight_end":45}],"label":"the trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Decode<'r, DB>`:\n  `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n  `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n  `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n  `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n  `&'r str` implements `sqlx::Decode<'r, Postgres>`\n  `()` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n  `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\nand 75 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::Metric` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":3787,"byte_end":3794,"line_start":144,"line_end":144,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":3787,"byte_end":3794,"line_start":144,"line_end":144,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3819,"byte_end":3825,"line_start":145,"line_end":145,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Metric {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Decode<'_, _>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:267:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let metrics = sqlx::query_as::<_, Metric>(\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Decode<'_, _>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Decode<'r, DB>`:\n              `&'a str` implements `sqlx::Decode<'a, sqlx::Any>`\n              `&'r JsonRawValue` implements `sqlx::Decode<'r, DB>`\n              `&'r [u8]` implements `sqlx::Decode<'r, Postgres>`\n              `&'r [u8]` implements `sqlx::Decode<'r, sqlx::Any>`\n              `&'r str` implements `sqlx::Decode<'r, Postgres>`\n              `()` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2)` implements `sqlx::Decode<'r, Postgres>`\n              `(T1, T2, T3)` implements `sqlx::Decode<'r, Postgres>`\n            and 75 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Metric` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:144:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m145\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Metric {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<_>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":8877,"byte_end":8883,"line_start":267,"line_end":267,"column_start":39,"column_end":45,"is_primary":true,"text":[{"text":"    let metrics = sqlx::query_as::<_, Metric>(","highlight_start":39,"highlight_end":45}],"label":"the trait `Type<_>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 77 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required for `models::Metric` to implement `for<'r> FromRow<'r, _>`","code":null,"level":"note","spans":[{"file_name":"src/models/mod.rs","byte_start":3787,"byte_end":3794,"line_start":144,"line_end":144,"column_start":24,"column_end":31,"is_primary":true,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":3787,"byte_end":3794,"line_start":144,"line_end":144,"column_start":24,"column_end":31,"is_primary":false,"text":[{"text":"#[derive(Debug, Clone, FromRow, Serialize)]","highlight_start":24,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(FromRow)]","def_site_span":{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-macros-0.8.6/src/lib.rs","byte_start":1750,"byte_end":1807,"line_start":57,"line_end":57,"column_start":1,"column_end":58,"is_primary":false,"text":[{"text":"pub fn derive_from_row(input: TokenStream) -> TokenStream {","highlight_start":1,"highlight_end":58}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/models/mod.rs","byte_start":3819,"byte_end":3825,"line_start":145,"line_end":145,"column_start":12,"column_end":18,"is_primary":true,"text":[{"text":"pub struct Metric {","highlight_start":12,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query_as`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12358,"byte_end":12366,"line_start":342,"line_end":342,"column_start":8,"column_end":16,"is_primary":false,"text":[{"text":"pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>","highlight_start":8,"highlight_end":16}],"label":"required by a bound in this function","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs","byte_start":12478,"byte_end":12506,"line_start":345,"line_end":345,"column_start":8,"column_end":36,"is_primary":true,"text":[{"text":"    O: for<'r> FromRow<'r, DB::Row>,","highlight_start":8,"highlight_end":36}],"label":"required by this bound in `query_as`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<_>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:267:39\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let metrics = sqlx::query_as::<_, Metric>(\n    \u001b[1m\u001b[94m|\u001b[0m                                       \u001b[1m\u001b[91m^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<_>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 77 others\n\u001b[1m\u001b[92mnote\u001b[0m: required for `models::Metric` to implement `for<'r> FromRow<'r, _>`\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:144:24\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m144\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Clone, FromRow, Serialize)]\n    \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[92m^^^^^^^\u001b[0m \u001b[1m\u001b[92munsatisfied trait bound introduced in this `derive` macro\u001b[0m\n\u001b[1m\u001b[94m145\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub struct Metric {\n    \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[92m^^^^^^\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query_as`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query_as.rs:345:8\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m342\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn query_as<'q, DB, O>(sql: &'q str) -> QueryAs<'q, DB, O, <DB as Database>::Arguments<'q>>\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[94m--------\u001b[0m \u001b[1m\u001b[94mrequired by a bound in this function\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m345\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     O: for<'r> FromRow<'r, DB::Row>,\n    \u001b[1m\u001b[94m|\u001b[0m        \u001b[1m\u001b[92m^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `query_as`\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: this error originates in the derive macro `FromRow` (in Nightly builds, run with -Z macro-backtrace for more info)\n\n"}
{"$message_type":"diagnostic","message":"the method `fetch_all` exists for struct `QueryAs<'_, Postgres, models::Metric, PgArguments>`, but its trait bounds were not satisfied","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n\nIn this case, you need to implement the `chocolate` method to fix the error:\n\n```\nstruct Mouth;\n\nimpl Mouth {\n    fn chocolate(&self) { // We implement the `chocolate` method here.\n        println!(\"Hmmm! I love chocolate!\");\n    }\n}\n\nlet x = Mouth;\nx.chocolate(); // ok!\n```\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":8857,"byte_end":9097,"line_start":267,"line_end":277,"column_start":19,"column_end":6,"is_primary":false,"text":[{"text":"    let metrics = sqlx::query_as::<_, Metric>(","highlight_start":19,"highlight_end":47},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        SELECT * FROM metrics ","highlight_start":1,"highlight_end":31},{"text":"        WHERE bot_id = $1 ","highlight_start":1,"highlight_end":27},{"text":"        AND timestamp > NOW() - INTERVAL '7 days'","highlight_start":1,"highlight_end":50},{"text":"        ORDER BY timestamp DESC","highlight_start":1,"highlight_end":32},{"text":"        LIMIT 1000","highlight_start":1,"highlight_end":19},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(bot_id)","highlight_start":1,"highlight_end":18},{"text":"    .fetch_all(&state.db)","highlight_start":1,"highlight_end":6}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":9097,"byte_end":9106,"line_start":277,"line_end":277,"column_start":6,"column_end":15,"is_primary":true,"text":[{"text":"    .fetch_all(&state.db)","highlight_start":6,"highlight_end":15}],"label":"method cannot be called on `QueryAs<'_, Postgres, models::Metric, PgArguments>` due to unsatisfied trait bounds","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/models/mod.rs","byte_start":3808,"byte_end":3825,"line_start":145,"line_end":145,"column_start":1,"column_end":18,"is_primary":false,"text":[{"text":"pub struct Metric {","highlight_start":1,"highlight_end":18}],"label":"doesn't satisfy `models::Metric: FromRow<'r, PgRow>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.40.0/src/decimal.rs","byte_start":3015,"byte_end":3033,"line_start":116,"line_end":116,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"pub struct Decimal {","highlight_start":1,"highlight_end":19}],"label":"doesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following trait bounds were not satisfied:\n`Decimal: Type<Postgres>`\n`Decimal: sqlx::Decode<'_, Postgres>`","code":null,"level":"note","spans":[{"file_name":"src/lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[],"label":"unsatisfied trait bound introduced in this `derive` macro","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0599]\u001b[0m\u001b[1m: the method `fetch_all` exists for struct `QueryAs<'_, Postgres, models::Metric, PgArguments>`, but its trait bounds were not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:277:6\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let metrics = sqlx::query_as::<_, Metric>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m ___________________-\u001b[0m\n\u001b[1m\u001b[94m268\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         SELECT * FROM metrics \n\u001b[1m\u001b[94m270\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         WHERE bot_id = $1 \n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m276\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .bind(bot_id)\n\u001b[1m\u001b[94m277\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .fetch_all(&state.db)\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[94m-\u001b[0m\u001b[1m\u001b[91m^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mmethod cannot be called on `QueryAs<'_, Postgres, models::Metric, PgArguments>` due to unsatisfied trait bounds\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0msrc/models/mod.rs:145:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m145\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Metric {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m-----------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `models::Metric: FromRow<'r, PgRow>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m::: \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/rust_decimal-1.40.0/src/decimal.rs:116:1\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m116\u001b[0m \u001b[1m\u001b[94m|\u001b[0m   pub struct Decimal {\n    \u001b[1m\u001b[94m|\u001b[0m   \u001b[1m\u001b[94m------------------\u001b[0m \u001b[1m\u001b[94mdoesn't satisfy `Decimal: Type<Postgres>` or `Decimal: sqlx::Decode<'_, Postgres>`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: the following trait bounds were not satisfied:\n            `Decimal: Type<Postgres>`\n            `Decimal: sqlx::Decode<'_, Postgres>`\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":8857,"byte_end":9128,"line_start":267,"line_end":278,"column_start":19,"column_end":11,"is_primary":true,"text":[{"text":"    let metrics = sqlx::query_as::<_, Metric>(","highlight_start":19,"highlight_end":47},{"text":"        r#\"","highlight_start":1,"highlight_end":12},{"text":"        SELECT * FROM metrics ","highlight_start":1,"highlight_end":31},{"text":"        WHERE bot_id = $1 ","highlight_start":1,"highlight_end":27},{"text":"        AND timestamp > NOW() - INTERVAL '7 days'","highlight_start":1,"highlight_end":50},{"text":"        ORDER BY timestamp DESC","highlight_start":1,"highlight_end":32},{"text":"        LIMIT 1000","highlight_start":1,"highlight_end":19},{"text":"        \"#","highlight_start":1,"highlight_end":11},{"text":"    )","highlight_start":1,"highlight_end":6},{"text":"    .bind(bot_id)","highlight_start":1,"highlight_end":18},{"text":"    .fetch_all(&state.db)","highlight_start":1,"highlight_end":26},{"text":"    .await","highlight_start":1,"highlight_end":11}],"label":"cannot infer type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:267:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m267\u001b[0m \u001b[1m\u001b[94m|\u001b[0m       let metrics = sqlx::query_as::<_, Metric>(\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m ___________________^\u001b[0m\n\u001b[1m\u001b[94m268\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         r#\"\n\u001b[1m\u001b[94m269\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         SELECT * FROM metrics \n\u001b[1m\u001b[94m270\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m         WHERE bot_id = $1 \n\u001b[1m\u001b[94m...\u001b[0m   \u001b[1m\u001b[91m|\u001b[0m\n\u001b[1m\u001b[94m277\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .fetch_all(&state.db)\n\u001b[1m\u001b[94m278\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m     .await\n    \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[91m|__________^\u001b[0m \u001b[1m\u001b[91mcannot infer type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"type annotations needed","code":{"code":"E0282","explanation":"The compiler could not infer a type and asked for a type annotation.\n\nErroneous code example:\n\n```compile_fail,E0282\nlet x = Vec::new();\n```\n\nThis error indicates that type inference did not result in one unique possible\ntype, and extra information is required. In most cases this can be provided\nby adding a type annotation. Sometimes you need to specify a generic type\nparameter manually.\n\nIn the example above, type `Vec` has a type parameter `T`. When calling\n`Vec::new`, barring any other later usage of the variable `x` that allows the\ncompiler to infer what type `T` is, the compiler needs to be told what it is.\n\nThe type can be specified on the variable:\n\n```\nlet x: Vec<i32> = Vec::new();\n```\n\nThe type can also be specified in the path of the expression:\n\n```\nlet x = Vec::<i32>::new();\n```\n\nIn cases with more complex types, it is not necessary to annotate the full\ntype. Once the ambiguity is resolved, the compiler can infer the rest:\n\n```\nlet x: Vec<_> = \"hello\".chars().rev().collect();\n```\n\nAnother way to provide the compiler with enough information, is to specify the\ngeneric type parameter:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<char>>();\n```\n\nAgain, you need not specify the full type if the compiler can infer it:\n\n```\nlet x = \"hello\".chars().rev().collect::<Vec<_>>();\n```\n\nApart from a method or function with a generic type parameter, this error can\noccur when a type parameter of a struct or trait cannot be inferred. In that\ncase it is not always possible to use a type annotation, because all candidates\nhave the same return type. For instance:\n\n```compile_fail,E0282\nstruct Foo<T> {\n    num: T,\n}\n\nimpl<T> Foo<T> {\n    fn bar() -> i32 {\n        0\n    }\n\n    fn baz() {\n        let number = Foo::bar();\n    }\n}\n```\n\nThis will fail because the compiler does not know which instance of `Foo` to\ncall `bar` on. Change `Foo::bar()` to `Foo::<T>::bar()` to resolve the error.\n"},"level":"error","spans":[{"file_name":"src/handlers/bots.rs","byte_start":9182,"byte_end":9183,"line_start":279,"line_end":279,"column_start":54,"column_end":55,"is_primary":false,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":54,"highlight_end":55}],"label":"type must be known at this point","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/bots.rs","byte_start":9143,"byte_end":9144,"line_start":279,"line_end":279,"column_start":15,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":15,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider giving this closure parameter an explicit type","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":9144,"byte_end":9144,"line_start":279,"line_end":279,"column_start":16,"column_end":16,"is_primary":true,"text":[{"text":"    .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;","highlight_start":16,"highlight_end":16}],"label":null,"suggested_replacement":": /* Type */","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0282]\u001b[0m\u001b[1m: type annotations needed\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:279:15\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m               \u001b[1m\u001b[91m^\u001b[0m                                      \u001b[1m\u001b[94m-\u001b[0m \u001b[1m\u001b[94mtype must be known at this point\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider giving this closure parameter an explicit type\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m279\u001b[0m \u001b[1m\u001b[94m| \u001b[0m    .map_err(|e\u001b[92m: /* Type */\u001b[0m| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;\n    \u001b[1m\u001b[94m|\u001b[0m                \u001b[92m++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5830,"byte_end":5843,"line_start":169,"line_end":169,"column_start":19,"column_end":32,"is_primary":true,"text":[{"text":"            .bind(metric.equity)","highlight_start":19,"highlight_end":32}],"label":"the trait `sqlx::Encode<'_, Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":5825,"byte_end":5829,"line_start":169,"line_end":169,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(metric.equity)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Encode<'q, DB>`:\n  `&'a str` implements `sqlx::Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `sqlx::Encode<'q, sqlx::Any>`\n  `&T` implements `sqlx::Encode<'q, DB>`\n  `&[T]` implements `sqlx::Encode<'q, Postgres>`\n  `&[u8]` implements `sqlx::Encode<'_, Postgres>`\n  `&str` implements `sqlx::Encode<'_, Postgres>`\n  `AssetFocus` implements `sqlx::Encode<'q, DB>`\n  `Box<[u8]>` implements `sqlx::Encode<'_, Postgres>`\nand 67 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs","byte_start":3088,"byte_end":3102,"line_start":86,"line_end":86,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":25,"highlight_end":39}],"label":"required by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Encode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:169:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .bind(metric.equity)\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Encode<'_, Postgres>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Encode<'q, DB>`:\n              `&'a str` implements `sqlx::Encode<'a, sqlx::Any>`\n              `&'q [u8]` implements `sqlx::Encode<'q, sqlx::Any>`\n              `&T` implements `sqlx::Encode<'q, DB>`\n              `&[T]` implements `sqlx::Encode<'q, Postgres>`\n              `&[u8]` implements `sqlx::Encode<'_, Postgres>`\n              `&str` implements `sqlx::Encode<'_, Postgres>`\n              `AssetFocus` implements `sqlx::Encode<'q, DB>`\n              `Box<[u8]>` implements `sqlx::Encode<'_, Postgres>`\n            and 67 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs:86:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5830,"byte_end":5843,"line_start":169,"line_end":169,"column_start":19,"column_end":32,"is_primary":true,"text":[{"text":"            .bind(metric.equity)","highlight_start":19,"highlight_end":32}],"label":"the trait `Type<Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":5825,"byte_end":5829,"line_start":169,"line_end":169,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(metric.equity)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 77 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs","byte_start":3105,"byte_end":3113,"line_start":86,"line_end":86,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":42,"highlight_end":50}],"label":"required by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5830,"byte_end":5830,"line_start":169,"line_end":169,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"            .bind(metric.equity)","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":5843,"byte_end":5843,"line_start":169,"line_end":169,"column_start":32,"column_end":32,"is_primary":true,"text":[{"text":"            .bind(metric.equity)","highlight_start":32,"highlight_end":32}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:169:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .bind(metric.equity)\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 77 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs:86:42\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m169\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .bind(\u001b[92m(\u001b[0mmetric.equity\u001b[92m,)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m+\u001b[0m             \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: sqlx::Encode<'_, Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5863,"byte_end":5873,"line_start":170,"line_end":170,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"            .bind(metric.pnl)","highlight_start":19,"highlight_end":29}],"label":"the trait `sqlx::Encode<'_, Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":5858,"byte_end":5862,"line_start":170,"line_end":170,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(metric.pnl)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `sqlx::Encode<'q, DB>`:\n  `&'a str` implements `sqlx::Encode<'a, sqlx::Any>`\n  `&'q [u8]` implements `sqlx::Encode<'q, sqlx::Any>`\n  `&T` implements `sqlx::Encode<'q, DB>`\n  `&[T]` implements `sqlx::Encode<'q, Postgres>`\n  `&[u8]` implements `sqlx::Encode<'_, Postgres>`\n  `&str` implements `sqlx::Encode<'_, Postgres>`\n  `AssetFocus` implements `sqlx::Encode<'q, DB>`\n  `Box<[u8]>` implements `sqlx::Encode<'_, Postgres>`\nand 67 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs","byte_start":3088,"byte_end":3102,"line_start":86,"line_end":86,"column_start":25,"column_end":39,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":25,"highlight_end":39}],"label":"required by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: sqlx::Encode<'_, Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:170:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m170\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .bind(metric.pnl)\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `sqlx::Encode<'_, Postgres>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `sqlx::Encode<'q, DB>`:\n              `&'a str` implements `sqlx::Encode<'a, sqlx::Any>`\n              `&'q [u8]` implements `sqlx::Encode<'q, sqlx::Any>`\n              `&T` implements `sqlx::Encode<'q, DB>`\n              `&[T]` implements `sqlx::Encode<'q, Postgres>`\n              `&[u8]` implements `sqlx::Encode<'_, Postgres>`\n              `&str` implements `sqlx::Encode<'_, Postgres>`\n              `AssetFocus` implements `sqlx::Encode<'q, DB>`\n              `Box<[u8]>` implements `sqlx::Encode<'_, Postgres>`\n            and 67 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs:86:25\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                         \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `Decimal: Type<Postgres>` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5863,"byte_end":5873,"line_start":170,"line_end":170,"column_start":19,"column_end":29,"is_primary":true,"text":[{"text":"            .bind(metric.pnl)","highlight_start":19,"highlight_end":29}],"label":"the trait `Type<Postgres>` is not implemented for `Decimal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":5858,"byte_end":5862,"line_start":170,"line_end":170,"column_start":14,"column_end":18,"is_primary":false,"text":[{"text":"            .bind(metric.pnl)","highlight_start":14,"highlight_end":18}],"label":"required by a bound introduced by this call","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `Type<DB>`:\n  `&T` implements `Type<DB>`\n  `()` implements `Type<Postgres>`\n  `(T1, T2)` implements `Type<Postgres>`\n  `(T1, T2, T3)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n  `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\nand 77 others","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`","code":null,"level":"note","spans":[{"file_name":"/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs","byte_start":3105,"byte_end":3113,"line_start":86,"line_end":86,"column_start":42,"column_end":50,"is_primary":true,"text":[{"text":"    pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {","highlight_start":42,"highlight_end":50}],"label":"required by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"use a unary tuple instead","code":null,"level":"help","spans":[{"file_name":"src/handlers/sync.rs","byte_start":5863,"byte_end":5863,"line_start":170,"line_end":170,"column_start":19,"column_end":19,"is_primary":true,"text":[{"text":"            .bind(metric.pnl)","highlight_start":19,"highlight_end":19}],"label":null,"suggested_replacement":"(","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/handlers/sync.rs","byte_start":5873,"byte_end":5873,"line_start":170,"line_end":170,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"            .bind(metric.pnl)","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":",)","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `Decimal: Type<Postgres>` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/sync.rs:170:19\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m170\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             .bind(metric.pnl)\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m----\u001b[0m \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Type<Postgres>` is not implemented for `Decimal`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[94mrequired by a bound introduced by this call\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mhelp\u001b[0m: the following other types implement trait `Type<DB>`:\n              `&T` implements `Type<DB>`\n              `()` implements `Type<Postgres>`\n              `(T1, T2)` implements `Type<Postgres>`\n              `(T1, T2, T3)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6)` implements `Type<Postgres>`\n              `(T1, T2, T3, T4, T5, T6, T7)` implements `Type<Postgres>`\n            and 77 others\n\u001b[1m\u001b[92mnote\u001b[0m: required by a bound in `sqlx::query::Query::<'q, DB, <DB as sqlx::Database>::Arguments<'q>>::bind`\n   \u001b[1m\u001b[94m--> \u001b[0m/home/jane/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/sqlx-core-0.8.6/src/query.rs:86:42\n    \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m86\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub fn bind<T: 'q + Encode<'q, DB> + Type<DB>>(mut self, value: T) -> Self {\n    \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[92m^^^^^^^^\u001b[0m \u001b[1m\u001b[92mrequired by this bound in `Query::<'q, DB, <DB as Database>::Arguments<'q>>::bind`\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: use a unary tuple instead\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m170\u001b[0m \u001b[1m\u001b[94m| \u001b[0m            .bind(\u001b[92m(\u001b[0mmetric.pnl\u001b[92m,)\u001b[0m)\n    \u001b[1m\u001b[94m|\u001b[0m                   \u001b[92m+\u001b[0m          \u001b[92m++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"the trait bound `RiskCaps: Clone` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/models/mod.rs","byte_start":6747,"byte_end":6770,"line_start":270,"line_end":270,"column_start":5,"column_end":28,"is_primary":true,"text":[{"text":"    pub risk_caps: RiskCaps,","highlight_start":5,"highlight_end":28}],"label":"the trait `Clone` is not implemented for `RiskCaps`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/models/mod.rs","byte_start":6474,"byte_end":6479,"line_start":261,"line_end":261,"column_start":41,"column_end":46,"is_primary":false,"text":[{"text":"#[derive(Debug, Serialize, Deserialize, Clone)]","highlight_start":41,"highlight_end":46}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"#[derive(Clone)]","def_site_span":{"file_name":"/usr/src/debug/rust/rustc-1.92.0-src/library/core/src/clone.rs","byte_start":9498,"byte_end":9513,"line_start":257,"line_end":257,"column_start":1,"column_end":16,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"consider annotating `RiskCaps` with `#[derive(Clone)]`","code":null,"level":"help","spans":[{"file_name":"src/models/mod.rs","byte_start":5043,"byte_end":5043,"line_start":195,"line_end":195,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"pub struct RiskCaps {","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"#[derive(Clone)]\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the trait bound `RiskCaps: Clone` is not satisfied\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/models/mod.rs:270:5\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m261\u001b[0m \u001b[1m\u001b[94m|\u001b[0m #[derive(Debug, Serialize, Deserialize, Clone)]\n    \u001b[1m\u001b[94m|\u001b[0m                                         \u001b[1m\u001b[94m-----\u001b[0m \u001b[1m\u001b[94min this derive macro expansion\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m270\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     pub risk_caps: RiskCaps,\n    \u001b[1m\u001b[94m|\u001b[0m     \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mthe trait `Clone` is not implemented for `RiskCaps`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider annotating `RiskCaps` with `#[derive(Clone)]`\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m195\u001b[0m \u001b[92m+ #[derive(Clone)]\u001b[0m\n\u001b[1m\u001b[94m196\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub struct RiskCaps {\n    \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unused variable: `message`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/handlers/bots.rs","byte_start":7854,"byte_end":7861,"line_start":240,"line_end":240,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":"    let (new_status, message) = match req.action {","highlight_start":22,"highlight_end":29}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/handlers/bots.rs","byte_start":7854,"byte_end":7861,"line_start":240,"line_end":240,"column_start":22,"column_end":29,"is_primary":true,"text":[{"text":"    let (new_status, message) = match req.action {","highlight_start":22,"highlight_end":29}],"label":null,"suggested_replacement":"_message","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unused variable: `message`\u001b[0m\n   \u001b[1m\u001b[94m--> \u001b[0msrc/handlers/bots.rs:240:22\n    \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m240\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     let (new_status, message) = match req.action {\n    \u001b[1m\u001b[94m|\u001b[0m                      \u001b[1m\u001b[33m^^^^^^^\u001b[0m \u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_message`\u001b[0m\n    \u001b[1m\u001b[94m|\u001b[0m\n    \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 11 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 11 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0282, E0382, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0282, E0382, E0599.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
